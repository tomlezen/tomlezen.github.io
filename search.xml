<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AndroidReinforcePlugin使用]]></title>
    <url>%2F2019%2F01%2F22%2Fandroid-reinforce-use-manual%2F</url>
    <content type="text"><![CDATA[因为公司每次应用发版都需要手动对apk进行360和乐固加固，感觉特别麻烦，因而在开发任务闲置时间开发了一个Gradle插件：AndroidReinforcePlugin，实现打包时自动完成360和乐固加固操作。 前言 插件开发的初衷是在CI中应用，但后面考虑到实际情况有可能会有本地打包，所以做很多兼容保证CI和本地as都能使用，因而配置稍有些复杂 因为没有拿到乐固的secretId和secretKey，所以乐固相关功能并没有做测试 配置参数说明插件主要靠配置参数来控制加固，所以先说明下配置参数详情 配置参数基本上都是支持：gradle文件、环境变量、动态properties，优先级：动态properties&gt;环境变量&gt;gradle，这样做是考虑比较复杂的使用场景，比如本地使用的是开发签名，而CI使用的是发布签名 等等 含义 gradle 环境变量 Properties 默认值 加固类型 reinforceType 不支持 reinforce_type null 是否支持360加固 support 不支持 support_360 false 360是否自动签名 autoSign 不支持 360_auto_sign true 360加固jar路径 path 360_PATH 360_path null 360-是否多渠道 mulpkg 不支持 360_mulpkg false 360-多渠道配置文件 mulpkgConfigPath 不支持 360_mulpkg_config_path null 360-增值服务配置 addConfig 不支持 360_add_config -x86 360-账户名 user 360_USER 360_pass null 360-账户密码 pass 360_PASS 360_path null 是否支持乐固 support 不支持 support_le false 乐固是否自动签名 autoSign 不支持 le_auto_sign true 乐固jar路径 path LE_PATH le_path 内置 乐固-secretId secretId LE_SECRET_ID le_secret_id null 乐固-secretKey secretKey LE_SECRET_KEY le_secret_key null 签名文件路径 signconfig配置 STORE_PATH store_path 根据signconfig 签名文件密码 signconfig配置 STORE_PASS store_pass 根据signconfig 签名key别名 signconfig配置 KEY_ALIAS store_key_alias 根据signconfig 签名key密码 signconfig配置 KEY_PASS store_key_pass 根据signconfig 部分参数说明如下： 加固类型值有5种 360 360加固 le 乐固加固 all 360和乐固加固 query 根据flavorName匹配加固关键字选择对应的加固类型（不区分大小写），包含360、qihu字符则使用360加固，包含yyb、legu、yingyongbao、tencent字符则使用乐固加固 空 不使用加固 插件已经内置乐固工具文件，但是还是建议使用自己加固，因为内置的没有更新 360加固工具每个os不一样，所以没办法内置，所以需要自己根据自己os配置 看着配置参数很多，如果不考虑复杂的情况配置很简单 具体使用应用插件 添加插件依赖 1234dependencies &#123; ... classpath &quot;com.tlz.tools:reinforce:1.0.0&quot;&#125; 应用插件 123apply plugin: &apos;com.tlz.androidreinforceplugin&apos; Gradle参数配置如果使用CI或者命令动态传参数可以不进行gradle配置 123456789101112131415161718192021222324252627282930313233AndroidReinForce &#123; //加固类型 四种方式 360 le all query 默认为空不使用任何加固 reinforceType = "" reinforce360 &#123; // 支持该加固 默认不支持 support = true // 是否自动加固 默认为true autoSign = true // 配置自己的360账号 user = "你的360账号" // 配置自己的360账号密码 pass = "你的360账号密码" // 配置自己的360加固文件路径 path = file("jiagu/jiagu.jar").absolutePath // 多渠道 默认为false // mulpkg = true // 多渠道文件配置路径 如果未开启多渠道 此参数可不填 // mulpkgConfigPath = file("mulpkg_config.txt").absolutePath &#125; reinforceLe &#123; // 支持该加固 默认不支持 support = true // 是否自动加固 默认为true // autoSign = true // 配置自己的乐固加固文件路径 可以选择不配置使用默认内置的 // path = file("ms-shield.jar").absolutePath // 配置自己的乐固secretId secretId = "你的secretId" // 配置自己的乐固secretKey secretKey = "你的secretKey" &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>GradlePlugin</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Kotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeamCity部署Android持续化集成]]></title>
    <url>%2F2019%2F01%2F18%2Fteamcity-deploy-android%2F</url>
    <content type="text"><![CDATA[公司持续集成用的是Jenkins，TeamCity是自己私下玩玩，感觉挺不错的，就是资料教程啥的比较少安装过程比较简单，这里略过，官方文档 创建项目 进入Administration 点击CreateProject，填写代码仓库地址，如果有账户密码填入即可，然后点击Proceed 填写项目名和构建配置名称，构建配置名称默认是Build，可根据自己需求更改，我这里改成了Pack，然后点击Proceed 配置 等待创建完成，勾选Gradle编译步骤，点击Use selected 一般需求是编译release包，所以修改下gradle任务，点击edit 将build改为assembleRelease，这里可根据自己工程配置buildType自行修改，Gradle Wrapper也可根据自己的需求选择对应配置的版本 JDK也可以根据需求配置不同版本 保存 配置apk输出路径，选择左侧功能列表General Setting，路径规则是源码路径 =&gt; 输出路径，一般情况下设置成app\build\outputs\apk =&gt; outputs就可以了，别忘了保存 配置ANROID_HOME环境变量，打开TeamCity/buildAgent/conf/buildAgent.properties文件，在末尾加载android sdk的路径： 1env.ANDROID_HOME=你的sdk路径 可选配置修改git配置 选择左侧功能列表Version Control Setting，点击Edit 修改触发规则 选择左侧功能列表Triggers，可以自己添加触发规则 如果不想自动触发，可以将规则关闭或者删除 自定义参数 选择左侧功能列表Parameters，添加自己需求的参数即可 运行 点击Run开启一个编译任务 生成的apk文件在Artifacts下]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TeamCity</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vps服务器上搭建Shadowsocks服务器]]></title>
    <url>%2F2018%2F05%2F05%2Fbuild-shadowsocks%2F</url>
    <content type="text"><![CDATA[搭建shadowsocks服务器之前得还需要一台vps服务器，这里就不介绍vps服务器购买方式，网上已有蛮多的教程并且每个商家的购买方式也不一。 安装环境安装epel扩展源和更新：12yum -y install epel-releaseyum update 安装pip:1yum -y install python-pip 查看pip是否安装成功:1pip -V 安装Shadowsocks和配置通过pip安装shadowsocks：1pip install shadowsocks 编辑配置文件:1vi /etc/shadowsocks.json 进入编辑模式并复制以下内容：1234567891011121314&#123; &quot;server&quot;: &quot;服务器的ip地址&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: &#123; &quot;8381&quot;: &quot;tomlezen1&quot;, &quot;8382&quot;: &quot;tomlezen2&quot;, &quot;8383&quot;: &quot;tomlezen3&quot;, &quot;8384&quot;: &quot;tomlezen4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; server: vps服务器地址 port_password: 配置多个账号和密码 method：加密方式如果不需要配置多账号：12345678910&#123; &quot;server&quot;: &quot;服务器的ip地址&quot;, &quot;server_port&quot;: &quot;8381&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;: &quot;password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 启动Shadowsocks:1ssserver -c /etc/shadowsocks.json -d start 这样就可以通过Shadowsocks客户端访问啦 安装配置SupervisorSupervisor是一个进程管理工具，可以很方便的监听、启动、停止、重启一个或多个进程安装:1pip install supervisor copy一份配置文件到etc目录:1echo_supervisord_conf &gt; /etc/supervisord.conf 打开配置文件:1vi /etc/supervisord.conf 进入编辑模式，在末尾添加上一下内容:12345[program:shadowsocks]command=ssserver -c /etc/shadowsocks.json -d startautostart=trueuser=rootdirect_stde=true 启动supervisor服务：1supervisord 这样就算完成啦，更多supervisor使用请参考官方文档]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle插件实现jenkins构建apk时自动进行360加固]]></title>
    <url>%2F2018%2F04%2F12%2Fdev-360-jiagu-gradle-plugin%2F</url>
    <content type="text"><![CDATA[360加固助手下载到360加固宝下载对应系统的助手，Linux版本下载需要关注其公众号，我之前没看文档而用Mac版本的代替折腾了很久；解压助手并将目录下的jiagu文件夹复制到对应Jenkins服务器上，具体放在什么位置你自己决定，只要能正常访问就行； Jenkins环境变量配置​ 环境变量名可根据自己的需要而定配置360加固文件夹路径，即上一步将jiagu文件夹放置的路径：配置360用户名和密码：配置AndroidSDK路径，因为我们需要使用Build Tools里面的工具对加固后的apk进行对齐和签名操作： Gradle插件开发项目创建新建Android工程360JiaGuPlugin（也可直接创建java工程，但Android工程方便调试开发）;新建Java Library模块plugin; 配置相关依赖在plugin的build.gradle文件新增以下依赖：build.gradle1234dependencies &#123; implementation gradleApi() implementation &quot;com.android.tools.build:gradle:3.1.0&quot;&#125; 创建加固任务新建JiaGuPlugin类并继承DefaultTask，完整代码如下:JiaGuPlugin.kt Koltin:language1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.tlz.jiagupluginimport com.android.build.gradle.AppExtensionimport org.gradle.api.DefaultTaskimport org.gradle.api.tasks.TaskActionimport java.io.BufferedReaderimport java.io.Fileimport java.io.InputStreamReaderclass JiaGuTask : DefaultTask() &#123; /** shell文件名. */ private val shellFileName = &quot;jiagu_360.sh&quot; @TaskAction fun run() &#123; val shellFile = project.file(shellFileName) // 先删除之前创建的shell文件. if (shellFile.exists()) &#123; shellFile.delete() &#125; shellFile.createNewFile() // 获取release apk文件路径. (project.extensions.getByName(&quot;android&quot;) as? AppExtension)?.apply &#123; applicationVariants.firstOrNull &#123; it.buildType.name == &quot;release&quot; &#125; ?.apply &#123; outputs.firstOrNull() ?.apply &#123; // android sdk 路径 val androidHome = System.getenv(&quot;ANDROID_HOME&quot;) // 获取最新版本的build-tool路径 val buildToolPath = File(&quot;$androidHome/build-tools&quot;).listFiles().last().absolutePath // 签名工具文件路径 val signerJarPath = &quot;$buildToolPath/apksigner&quot; // 对齐工具文件路径 val zipalignJarPath = &quot;$buildToolPath/zipalign&quot; // 加固jar文件路径 val jiaguJarPath = &quot;$&#123;System.getenv(&quot;360JIAGU_PATH&quot;)&#125;/jiagu.jar&quot; // 360加固用户名 val user = System.getenv(&quot;360JIAGU_USER&quot;) // 360加固用户密码 val password = System.getenv(&quot;360JIAGU_PWD&quot;) // 获取签名文件路径及密码 val keyPath = signingConfig.storeFile.absolutePath val keyPass = signingConfig.storePassword val apkPath = outputFile.absolutePath // release apk文件名 val apkFileName = outputFile.nameWithoutExtension // 加固输出文件夹 val outApkPath = outputFile.parentFile.absolutePath // 加固后的文件 val jiaguFilePath = &quot;$outApkPath/$&#123;apkFileName&#125;_$&#123;versionName.replace(&quot;.&quot;, &quot;&quot;)&#125;_jiagu.apk&quot; // apk对齐后的输出文件 val zipOutPath = &quot;$outApkPath/$&#123;apkFileName&#125;_aligned.apk&quot; // 构建shell文件的内容 val shCode = StringBuilder() shCode.append(&quot;#!/bin/bash\n\n&quot;) // 登陆加固账户 shCode.append(&quot;java -jar $jiaguJarPath -login $user $password\n&quot;) // 执行加固 shCode.append(&quot;java -jar $jiaguJarPath -jiagu $apkPath $outApkPath\n&quot;) // 对apk 进行对齐操作 shCode.append(&quot;echo \&quot;------ zipalign start ------\&quot;\n&quot;) shCode.append(&quot;$signerJarPath -v 4 $jiaguFilePath $zipOutPath\n&quot;) shCode.append(&quot;echo \&quot;------ zipalign finish ------\&quot;\n&quot;) // 对apk进行签名 shCode.append(&quot;echo \&quot;------ sign start ------\&quot;\n&quot;) shCode.append(&quot;$zipalignJarPath sign --ks $keyPath $zipOutPath &lt;&lt;EOF\n&quot; + &quot;$keyPass\n&quot; + &quot;EOF&quot;) shCode.append(&quot;echo \&quot;------ sign finish ------\&quot;\n&quot;) shellFile.writeText(shCode.toString()) // 执行shell文件 val pro = Runtime.getRuntime().exec(&quot;sh $&#123;shellFile.absolutePath&#125; &gt;&gt; logfile&quot;) pro.waitFor() // 读取并输出结果 val read = BufferedReader(InputStreamReader(pro.inputStream)) var line: String? = read.readLine() while (line != null) &#123; println(line) line = read.readLine() &#125; // 删除加固文件 File(jiaguFilePath).delete() // 重命名已签名的文件 if (File(zipOutPath).renameTo(File(&quot;$outApkPath/$&#123;apkFileName&#125;_signed.apk&quot;))) &#123; println(&quot;重命名文件成功&quot;) &#125; &#125; &#125; &#125; &#125;&#125;如果需要多渠道打包，请参考360加固的命令行说明，对以上处理代码做出相应调整即可 创建插件并初始化任务在插件中创建加固任务并在assembleRelease任务结束时执行加固任务，完整代码如下：JiaGuPlugin.kt Kotlin:language123456789101112131415161718192021222324252627282930313233343536package com.tlz.jiagupluginimport org.gradle.api.Pluginimport org.gradle.api.internal.project.ProjectInternalimport javax.inject.Injectopen class JiaGuPlugin @Inject constructor() : Plugin&lt;ProjectInternal&gt; &#123; override fun apply(project: ProjectInternal?) &#123; project?.let &#123; it.afterEvaluate &#123; if (check360JiaguEnv()) &#123; // 创建任务 it.tasks.create(&quot;jiagu_360&quot;, JiaGuTask::class.java) // 在assembleRelease任务结束后执行jiagu_360任务 it.tasks.findByPath(&quot;assembleRelease&quot;)?.apply &#123; finalizedBy(&quot;jiagu_360&quot;) &#125; &#125; &#125; &#125; &#125; /** * 检查360加固环境变量是否存在. * @return Boolean */ private fun check360JiaguEnv(): Boolean &#123; // 360加固文件路径 val path = System.getenv(&quot;360JIAGU_PATH&quot;) // 360加固用户名 val user = System.getenv(&quot;360JIAGU_USER&quot;) // 360加固账户密码 val password = System.getenv(&quot;360JIAGU_PWD&quot;) return path?.isNotEmpty() == true &amp;&amp; user?.isNotEmpty() == true &amp;&amp; password?.isNotEmpty() == true &#125;&#125; 配置插件Gradle插件开发步骤及配置这里就不再叙述，网上有很多教程。 在本地发布插件在build.gradle文件应用maven插件，并配置uploadArchives任务，完整build.gradle文件如下:build.gradle12345678910111213141516171819202122232425apply plugin: &apos;java-library&apos;apply plugin: &apos;kotlin&apos;apply plugin: &apos;maven&apos;group &apos;com.tlz.jiaguplugin&apos;// 发布版本号version &apos;1.0.0&apos;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation&quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot; implementation gradleApi() implementation &quot;com.android.tools.build:gradle:3.1.0&quot;&#125;sourceCompatibility = &quot;1.7&quot;targetCompatibility = &quot;1.7&quot;uploadArchives&#123; repositories &#123; mavenDeployer &#123; repository(url: uri(&apos;./repo&apos;)) &#125; &#125;&#125;在Terminal输入命令gradlew uploadArchives发布，完成后plugin文件下会有一个名为repo的文件夹，里面就是刚才发布的插件。 应用插件并测试在工程下的build.gradle里依赖刚才发布的插件：在app的build.gradle里应用插件apply plugin: &#39;com.tlz.jiaguplugin&#39;，插件名为.properties的文件名。在Jenkins上集成该项目，自动构建结束在app.build.outputs.apk.release下的.xxx_signed.apk为加固并签名成功的文件。 结束到此就结束了，测试成功后最好将插件发布到公司内部或远程仓库，方便项目依赖使用[参考文章]: https://blog.csdn.net/likuan0214/article/details/75090103]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Kotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改BottomSheetDialogFragment背景]]></title>
    <url>%2F2018%2F03%2F30%2Fsetting-bottomsheetdialogfragment-background%2F</url>
    <content type="text"><![CDATA[BottomSheetDialogFragment是Design支持库里的组件，在日常开发中也经常用到。有时候会遇到一些特殊的需求，如：修改BottomSheetDialogFragment的默认背景，然而组件并没有提供直接修改背景的API。怎么办，我也很绝望啊！ 从源码中找线索在BottomSheetDialog源码的getThemeResId方法中可以看到默认的主题为R.style.Theme_Design_Light_BottomSheetDialog，似乎感觉到了点希望：BottomSheetDialog.java1234567891011121314private static int getThemeResId(Context context, int themeId) &#123; if (themeId == 0) &#123; // If the provided theme is 0, then retrieve the dialogTheme from our theme TypedValue outValue = new TypedValue(); if (context.getTheme().resolveAttribute( R.attr.bottomSheetDialogTheme, outValue, true)) &#123; themeId = outValue.resourceId; &#125; else &#123; // bottomSheetDialogTheme is not provided; we default to our light theme themeId = R.style.Theme_Design_Light_BottomSheetDialog; &#125; &#125; return themeId;&#125;进入R.style.Theme_Design_Light_BottomSheetDialog源码文件：values.xml12345&lt;style name=&quot;Theme.Design.Light.BottomSheetDialog&quot; parent=&quot;Theme.AppCompat.Light.Dialog&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/Animation.Design.BottomSheetDialog&lt;/item&gt; &lt;item name=&quot;bottomSheetStyle&quot;&gt;@style/Widget.Design.BottomSheet.Modal&lt;/item&gt;&lt;/style&gt;可以看到一个名为bottomSheetStyle的属性，其值为@style/Widget.Design.BottomSheet.Modal，瞬间感觉希望大大的了，再进入其源码：values.xml1234567&lt;style name=&quot;Widget.Design.BottomSheet.Modal&quot; parent=&quot;android:Widget&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;?android:attr/colorBackground&lt;/item&gt; &lt;item name=&quot;android:elevation&quot; ns1:ignore=&quot;NewApi&quot;&gt;@dimen/design_bottom_sheet_modal_elevation&lt;/item&gt; &lt;item name=&quot;behavior_peekHeight&quot;&gt;auto&lt;/item&gt; &lt;item name=&quot;behavior_hideable&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;behavior_skipCollapsed&quot;&gt;false&lt;/item&gt;&lt;/style&gt;android:background，哈哈，背景，不多说赶紧试试！ 测试验证在styles.xml中添加一个继承于Widget.Design.BottomSheet.Modal的styleCustomBottomSheetStyle，重写android:background，我这里设置的背景为透明：styles.xml123&lt;style name=&quot;CustomBottomSheetStyle&quot; parent=&quot;Widget.Design.BottomSheet.Modal&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt;再添加一个继承于Theme.Design.Light.BottomSheetDialog的styleCustomBottomSheetDialogTheme，重写bottomSheetStyle属性：styles.xml123&lt;style name=&quot;CustomBottomSheetDialogTheme&quot; parent=&quot;Theme.Design.Light.BottomSheetDialog&quot;&gt; &lt;item name=&quot;bottomSheetStyle&quot;&gt;@style/CustomBottomSheetStyle&lt;/item&gt;&lt;/style&gt;再在CustomBottomSheetDialogFragment中重写getTheme方法：CustomBottomSheetDialogFragment.kt1override fun getTheme(): Int = R.style.CustomBottomSheetDialogTheme运行查看效果：Nice good !]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows上运行Kotlin Native第一个程序：Hello World]]></title>
    <url>%2F2018%2F03%2F28%2Fkotlin-native-hello-world%2F</url>
    <content type="text"><![CDATA[编译Kotlin Native源码克隆源码如果不想编译源码，也可以直接下载官方编译好的：下载地址克隆github上的源码：1$ git clone https://github.com/JetBrains/kotlin-native.git 编译源码进入源码文件夹：1$ cd kotlin-native 更新下载依赖：1$ gradlew dependencies:update 执行编译：1$ gradlew dist 编译完后会在源码目录生成一个dist文件夹，Kotlin Native编译器在dist/bin下。这里我将dist整个文件夹拷贝到G盘的KotlinNative文件夹下（此步骤不是必须的，我这样做主要方便以后使用。 创建Hello World创建工程并配置打开IDEA新建一个名为KotlinNativeHelloWorld的工程:创建HelloWorld.kt文件并写上打印Hello World！的main方法:HelloWorld.kt123fun main(args: Array&lt;String&gt;) &#123; println(&quot;Hello World！&quot;)&#125;在build.gradle文件增加以下配置:Kotlin Native插件依赖1234dependencies &#123; ... classpath &quot;org.jetbrains.kotlin:kotlin-native-gradle-plugin:+&quot;&#125;插件仓库地址123456repositories &#123; ... maven &#123; url &quot;https://dl.bintray.com/jetbrains/kotlin-native-dependencies&quot; &#125;&#125;应用插件1apply plugin: &apos;konan&apos;告诉konan需要编译的程序，可以配置多个123konanArtifacts &#123; program(&apos;HelloWorld&apos;)&#125;在gradle.properties（如果没有该文件，自己创建一个即可）配置konan编译器路径。因为我之前将编译好的拷贝到了G盘下，所以这里的路径是G盘下的，如果你之前没有拷贝，请采用源码下对应的路径：1konan.home=G:/KotlinNative/dist 编译运行配置完后在Terminal里输入gradlew compileKonan命令进行编译：1$ gradlew compileKonan 完后，在build/konan/bin/mingw_x64下会又一个名为HelloWorld.exe的文件，然后运行这个exe文件：12$ cd build/konan/bin/mingw_x64$ HelloWorld.exe 可以看到输出了Hello World！文字，这样就算成功啦！]]></content>
      <categories>
        <category>技术</category>
        <category>Kotlin-Native</category>
      </categories>
      <tags>
        <tag>Kotlin Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有感]]></title>
    <url>%2F2018%2F03%2F26%2Fcreate-personal-blog-experience%2F</url>
    <content type="text"><![CDATA[2018年3月26日晚，个人博客终于搭建完成，内心还是蛮激动的。由于自己技术比较菜，捣腾了好久才完成，踩了不少坑，走了不少弯路，光Github Pages绑定域名都弄了一下午。不过在这过程中，自己又学会了不少的技能，不亏不亏，哈哈！希望这是一个新的开始、好的开始！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Github Pages绑定自己的域名]]></title>
    <url>%2F2018%2F03%2F25%2Fbind-domain%2F</url>
    <content type="text"><![CDATA[创建CNAME文件进入博客网站根录，在source目录下新建一个名为CNAME的文件，不要建在public目录下，因为在执行hexo clean命令时public目录下的文件都会被删除；打开CNAME文件并填写你的域名xx.com，一定不要写www.；通过hexo d命令重新发布网站; DNS解析配置我这里以GoDadyy的配置为例；登陆Godaddy并进入DNS管理，现在修改名称为www的记录，把值修改为你的Github Pages访问地址xxx.github.io，以便能通过www.xx.com访问：点击添加按钮，添加一条记录，类型选择A，主机填写@，指向填写192.30.252.153，选择@类型是为让xx.com能正确访问:再次点击添加按钮，添加一条记录，类型选择A，主机填写@，指向填写192.30.252.154:完整配置效果如下：至此你的域名xx.com就能正确访问啦，有时域名解析有点慢，请耐心等待一会儿！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Github Pages</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github Pages、Hexo搭建个人博客]]></title>
    <url>%2F2018%2F03%2F24%2Fcreate-personal-blog%2F</url>
    <content type="text"><![CDATA[Github Pages免费给开发者托管个人网站，但是只能托管静态内容，但是对于一般的博客网站足矣。Hexo是一个开源、简洁高效的博客框架，可以帮助开发者快速搭建自己的博客网站。 基础开发环境搭建安装配置Nodejs安装配置Git，安装完后记得进行以下配置：12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 安装配置Hexo安装hexo-cli1$ npm install hexo-cli -g 创建博客网站初始化新建一个网站项目，即网站生成的路径，如果不设置会默认在当前目录下创建：1$ npm init &lt;folder&gt; 安装相关依赖模块：12$ cd &lt;folder&gt; $ npm install 安装完成之后，文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 3. 对网站进行相关配置打开_config.yml文件，可进行如下修改： 12345title: 你的网站标题subtitle: 你的网站副标题description: 你的网站描述author: 你的名字language: zh-CN 更多的详细配置请参考官方文档 预览网站启动服务器，在浏览器中访问http://localhost:4000/，可以看到一篇名为Hello World的博文：1$ hexo server 新建博文创建123$ hexo new post new-blog // 'new-blog'您可以任意指定名字或$ hexo new new-blog 执行成功后在source/_posts文件夹下会有一个名为：new-blog.md的文件。注意：Hexo有三种默认布局：post、page和draft，使用hexo new时默认布局为post 编辑打开new-blog.md文件，里面的内容如下：修改文章：title: 新博客添加标签，两种写法：1234567tags: [学习, 练习, Blog]或tags:- 学习- 练写- Blog// 注意第二种写法的空格 添加分类，写法与标签一样：12categories:- 学习 在---线下面填写博文内容：1这是我建立的第一篇博文！ 完整内容如下：1234567891011---title: 新博客date: 2018-03-25 10:29:04tags: - 学习- 练习- Blogcategories:- 学习---这是我新建的第一篇博文 重新启动网站hexo server，效果如下（我这里使用了主题，效果可能会有所不同）： Github Pages配置Github账号、仓库创建Github官网：通过邮箱注册一个账号；登陆Github，在主界面点击右上边的New repository按钮开始创建一个代码仓库；在Repository name填写仓库名，格式必须为xxx.github.io，xxx即为你的Github用户名，千万别填写错误，然后点击Create respository按钮完成创建： 添加SSH Key官方文档打开git bash，输入以下命令检查是否已存在id_rsa.pub或者id_dsa.pub，如果存在请移步复制key：1$ ls -al ~/.ssh 创建ssh key：12$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"// 别忘了换成你自己Github邮箱地址，命令执行后需要点击三次点击Enter键即可保存成功 复制key：1234567mac:$ pbcopy &lt; ~/.ssh/id_rsa.pubwindows:$ clip &lt; ~/.ssh/id_rsa.publinux:$ sudo apt-get install xclip$ xclip -sel clip &lt; ~/.ssh/id_rsa.pub 添加到Github账户，依次点击Settings-&gt;SSH and GPG keys，进入SSH and GPG keys管理界面，Github帮助文档:点击 New SSH key按钮新建key：输入Title可随意指定，并在key输入框内粘贴之前复制的key：最后点击Add SSH key，确认创建 部署网站配置github仓库地址打开网站目录下的_config.yml文件，进行如下修改：1234deploy: type: git repo: git@github.com:tomlezen/tomlezen.github.io.git branch: master repo参数为之前在github上创建的xxx.github.io仓库SSH地址，点击下图箭头所指的按钮即可快速复制： 部署1hexo deploy 等待部署完成，刷新github仓库就可以看到相关网站代码了 成果在浏览器中输入xxx.github.io（xxx为你的Github用户名）就能访问你的博客啦。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Github Pages</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
